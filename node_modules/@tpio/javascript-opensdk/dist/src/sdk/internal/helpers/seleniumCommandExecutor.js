"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const http_1 = require("selenium-webdriver/http");
const selenium_webdriver_1 = require("selenium-webdriver");
const stack_trace_1 = require("stack-trace");
const lodash_1 = require("lodash");
const sleep_promise_1 = __importDefault(require("sleep-promise"));
const customHttpClient_1 = __importDefault(require("./customHttpClient"));
const agentClient_1 = __importDefault(require("../agent/agentClient"));
const reporter_1 = __importDefault(require("../../reporter/reporter"));
const reportHelper_1 = __importDefault(require("./reportHelper"));
const stepSettings_1 = __importDefault(require("../../../classes/stepSettings"));
const driverCommandReport_1 = __importDefault(require("../../../rest/messages/driverCommandReport"));
const logger_1 = __importDefault(require("../../../logger/logger"));
const customTestReport_1 = __importDefault(require("../../../rest/messages/customTestReport"));
const customCapabilities_1 = __importDefault(require("./customCapabilities"));
const seleniumHelper_1 = require("./seleniumHelper");
const redactHelper_1 = __importDefault(require("./redactHelper"));
class CustomHttpCommandExecutor extends http_1.Executor {
    constructor(capabilities) {
        const httpClient = new customHttpClient_1.default();
        super(httpClient);
        this.agentClient = new agentClient_1.default(capabilities);
        this.reporter = new reporter_1.default(this.agentClient, this.getScreenshot.bind(this));
        if (capabilities.get(customCapabilities_1.default.DISABLE_REPORTS)) {
            this.reporter.disableReports = true;
        }
        this.httpClient = httpClient;
        this.driverSessionId = '';
        this.latestKnownTestName = '';
        this.excludedTestNames = [];
        this.disableRedaction = false;
        this.isWebdriverWait = false;
        this.settings = new stepSettings_1.default();
        this.w3c = true;
    }
    execute(command, skipReporting = false) {
        const _super = Object.create(null, {
            execute: { get: () => super.execute }
        });
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const cmdName = command.getName();
            if (cmdName === seleniumHelper_1.SeleniumCommandName.NEW_SESSION) {
                const agentResponse = yield this.agentClient.startSession();
                logger_1.default.debug(`WebDriver Address: ${agentResponse.serverAddress}`);
                this.httpClient.setDriverAddr(agentResponse.serverAddress);
                this.driverSessionId = agentResponse.sessionId;
                this.w3c = agentResponse.dialect === 'W3C';
                return new selenium_webdriver_1.Session(agentResponse.sessionId, agentResponse.capabilities);
            }
            if (cmdName === seleniumHelper_1.SeleniumCommandName.QUIT) {
                if (!this.reporter.disableTestAutoReports) {
                    this.reportTest();
                }
                _super.execute.call(this, command);
                yield this.agentClient.quitSession();
                return Promise.resolve();
            }
            const currentTestName = reportHelper_1.default.inferTestName();
            if (!this.reporter.disableTestAutoReports &&
                this.latestKnownTestName.length > 0 &&
                this.latestKnownTestName !== currentTestName) {
                this.reportTest();
            }
            this.latestKnownTestName = currentTestName;
            yield this.handleTimeOut((_a = this.settings) === null || _a === void 0 ? void 0 : _a.timeout, (_b = this.sessionId) !== null && _b !== void 0 ? _b : '');
            yield CustomHttpCommandExecutor.handleSleep(this.settings.sleepTimingType, this.settings.sleepTime, command);
            let response;
            const copiedCommand = lodash_1.cloneDeep(command);
            const autoCommandReport = !skipReporting && CustomHttpCommandExecutor.NON_REPORTED_COMMANDS.indexOf(command.getName()) === -1;
            try {
                response = yield _super.execute.call(this, command);
            }
            catch (error) {
                if (autoCommandReport) {
                    yield this.reportCommand(copiedCommand, response, false);
                }
                throw error;
            }
            yield CustomHttpCommandExecutor.handleSleep(this.settings.sleepTimingType, this.settings.sleepTime, copiedCommand);
            if (autoCommandReport) {
                yield this.reportCommand(copiedCommand, response, true);
            }
            return response;
        });
    }
    updateKnownTestName() {
        const currentTestName = reportHelper_1.default.inferTestName();
        this.latestKnownTestName = currentTestName;
    }
    reportCommand(command, result, passed) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.disableRedaction) {
                const newParameters = yield new redactHelper_1.default(this).redactCommand(command);
                command.setParameters(newParameters);
            }
            this.isWebdriverWait = false;
            const callStackList = stack_trace_1.get();
            callStackList.forEach((file) => {
                var _a;
                if ((_a = file === null || file === void 0 ? void 0 : file.getFileName()) === null || _a === void 0 ? void 0 : _a.includes('wait')) {
                    this.isWebdriverWait = true;
                }
            });
            const testPassed = this.settings.invertResult ? !passed : passed;
            const driverCommandReport = new driverCommandReport_1.default(command, result, testPassed);
            let takeScreenshot = false;
            if (this.settings.screenshotCondition === 3 && !passed) {
                takeScreenshot = true;
            }
            else if (this.settings.screenshotCondition === 2 && passed) {
                takeScreenshot = true;
            }
            else if (this.settings.screenshotCondition === 4) {
                takeScreenshot = true;
            }
            if (takeScreenshot) {
            }
            if (this.isWebdriverWait) {
                if (!this.reporter.disableReports && !this.reporter.disableCommandReports) {
                    this.stashedCommand = driverCommandReport;
                }
                return;
            }
            if (!this.reporter.disableReports && !this.reporter.disableCommandReports) {
                if (this.stashedCommand) {
                    this.agentClient.reportDriverCommand(this.stashedCommand);
                    this.stashedCommand = undefined;
                }
                this.agentClient.reportDriverCommand(driverCommandReport);
            }
        });
    }
    reportTest() {
        if (this.latestKnownTestName !== 'Unnamed Test') {
            if (this.reporter.disableReports) {
                logger_1.default.debug(`Test ${this.latestKnownTestName} - [Passed]`);
                return;
            }
            if (this.excludedTestNames.includes(this.latestKnownTestName)) {
                logger_1.default.debug(`Test ${this.latestKnownTestName} - Reporting skipped (marked as 'To be excluded'`);
                return;
            }
            this.agentClient.reportTest(new customTestReport_1.default(this.latestKnownTestName, true));
        }
    }
    getScreenshot() {
        return __awaiter(this, void 0, void 0, function* () {
            const command = seleniumHelper_1.SeleniumHelper.buildSeleniumCommand(seleniumHelper_1.SeleniumCommandName.SCREENSHOT);
            command.setParameter('sessionId', this.agentClient.agentSession.sessionId);
            return this.execute(command, true);
        });
    }
    handleTimeOut(timeout, sessionId) {
        const _super = Object.create(null, {
            execute: { get: () => super.execute }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (timeout > 0) {
                const command = this.w3c
                    ? seleniumHelper_1.SeleniumHelper.buildSeleniumCommand(seleniumHelper_1.SeleniumCommandName.SET_TIMEOUT).setParameter('implicit', timeout)
                    : seleniumHelper_1.SeleniumHelper.buildSeleniumCommand(seleniumHelper_1.SeleniumCommandName.IMPLICITLY_WAIT).setParameter('ms', timeout);
                command.setParameter('sessionId', sessionId);
                yield _super.execute.call(this, command);
            }
        });
    }
    static handleSleep(sleep_timing_type, sleep_time, command, step_executed = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (command.getName() !== seleniumHelper_1.SeleniumCommandName.QUIT) {
                if (sleep_timing_type !== 0) {
                    const sleepTimingTypeCondition = step_executed ? 3 : 2;
                    if (sleep_timing_type === sleepTimingTypeCondition) {
                        logger_1.default.debug(`Step is designed to sleep for ${sleep_time} milliseconds`);
                        logger_1.default.debug(`${sleep_timing_type} execution.`);
                        yield sleep_promise_1.default(sleep_time);
                    }
                }
            }
        });
    }
    get sessionId() {
        return this.driverSessionId;
    }
}
exports.default = CustomHttpCommandExecutor;
CustomHttpCommandExecutor.NON_REPORTED_COMMANDS = [
    seleniumHelper_1.SeleniumCommandName.NEW_SESSION,
    seleniumHelper_1.SeleniumCommandName.QUIT,
    seleniumHelper_1.SeleniumCommandName.SET_TIMEOUT,
];
