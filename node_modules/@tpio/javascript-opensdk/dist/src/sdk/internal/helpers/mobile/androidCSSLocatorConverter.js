"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const css_selector_parser_1 = require("css-selector-parser");
const lodash_1 = require("lodash");
const parser = new css_selector_parser_1.CssSelectorParser();
parser.registerSelectorPseudos('has');
parser.registerNestingOperators('>', '+', '~');
parser.registerAttrEqualityMods('^', '$', '*', '~');
parser.enableSubstitutes();
const RESOURCE_ID = 'resource-id';
const ID_LOCATOR_PATTERN = /^[a-zA-Z_][a-zA-Z0-9._]*:id\/[\S]+$/;
const BOOLEAN_ATTRS = [
    'checkable',
    'checked',
    'clickable',
    'enabled',
    'focusable',
    'focused',
    'long-clickable',
    'scrollable',
    'selected',
];
const NUMERIC_ATTRS = ['index', 'instance'];
const STR_ATTRS = ['description', RESOURCE_ID, 'text', 'class-name', 'package-name'];
const ALL_ATTRS = [...BOOLEAN_ATTRS, ...NUMERIC_ATTRS, ...STR_ATTRS];
const ATTRIBUTE_ALIASES = [
    [RESOURCE_ID, ['id']],
    ['description', ['content-description', 'content-desc', 'desc', 'accessibility-id']],
    ['index', ['nth-child']],
];
function toSnakeCase(str) {
    if (!str) {
        return '';
    }
    const tokens = str.split('-').map((str) => str.charAt(0).toUpperCase() + str.slice(1).toLowerCase());
    const out = tokens.join('');
    return out.charAt(0).toLowerCase() + out.slice(1);
}
function assertGetBool(css) {
    var _a;
    const val = ((_a = css.value) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || 'true';
    if (['true', 'false'].includes(val)) {
        return val;
    }
    throw new Error(`'${css.name}' must be true, false or empty. Found '${css.value}'`);
}
function assertGetAttrName(css) {
    const attrName = css.name.toLowerCase();
    if (ALL_ATTRS.includes(attrName)) {
        return attrName.toLowerCase();
    }
    for (const [officialAttr, aliasAttrs] of ATTRIBUTE_ALIASES) {
        if (aliasAttrs.includes(attrName)) {
            return officialAttr;
        }
    }
    throw new Error(`'${attrName}' is not a valid attribute. ` + `Supported attributes are '${ALL_ATTRS.join(', ')}'`);
}
function getWordMatcherRegex(word) {
    return `\\b(\\w*${lodash_1.escapeRegExp(word)}\\w*)\\b`;
}
function formatIdLocator(locator) {
    return ID_LOCATOR_PATTERN.test(locator) ? locator : `android:id/${locator}`;
}
function parseAttr(cssAttr) {
    if (cssAttr.valueType && cssAttr.valueType !== 'string') {
        throw new Error(`'${cssAttr.name}=${cssAttr.value}' is an invalid attribute. ` +
            `Only 'string' and empty attribute types are supported. Found '${cssAttr.valueType}'`);
    }
    const attrName = assertGetAttrName(cssAttr);
    const methodName = toSnakeCase(attrName);
    if (!STR_ATTRS.includes(attrName) && !BOOLEAN_ATTRS.includes(attrName)) {
        throw new Error(`'${attrName}' is not supported. Supported attributes are ` + `'${[...STR_ATTRS, ...BOOLEAN_ATTRS].join(', ')}'`);
    }
    if (BOOLEAN_ATTRS.includes(attrName)) {
        return `.${methodName}(${assertGetBool(cssAttr)})`;
    }
    let value = cssAttr.value || '';
    if (attrName === RESOURCE_ID) {
        value = formatIdLocator(value);
    }
    if (value === '') {
        return `.${methodName}Matches("")`;
    }
    switch (cssAttr.operator) {
        case '=':
            return `.${methodName}("${value}")`;
        case '*=':
            if (['description', 'text'].includes(attrName)) {
                return `.${methodName}Contains("${value}")`;
            }
            return `.${methodName}Matches("${lodash_1.escapeRegExp(value)}")`;
        case '^=':
            if (['description', 'text'].includes(attrName)) {
                return `.${methodName}StartsWith("${value}")`;
            }
            return `.${methodName}Matches("^${lodash_1.escapeRegExp(value)}")`;
        case '$=':
            return `.${methodName}Matches("${lodash_1.escapeRegExp(value)}$")`;
        case '~=':
            return `.${methodName}Matches("${getWordMatcherRegex(value)}")`;
        default:
            throw new Error(`Unsupported CSS attribute operator '${cssAttr.operator}'. ` + ` '=', '*=', '^=', '$=' and '~=' are supported.`);
    }
}
function parsePseudo(cssPseudo) {
    if (cssPseudo.valueType && cssPseudo.valueType !== 'string') {
        throw new Error(`'${cssPseudo.name}=${cssPseudo.value}'. ` +
            `Unsupported css pseudo class value type: '${cssPseudo.valueType}'. Only 'string' type or empty is supported.`);
    }
    const pseudoName = assertGetAttrName(cssPseudo);
    if (BOOLEAN_ATTRS.includes(pseudoName)) {
        return `.${toSnakeCase(pseudoName)}(${assertGetBool(cssPseudo)})`;
    }
    if (NUMERIC_ATTRS.includes(pseudoName)) {
        return `.${pseudoName}(${cssPseudo.value})`;
    }
    return undefined;
}
function parseCssRule(cssRule) {
    const { nestingOperator } = cssRule;
    if (nestingOperator && nestingOperator !== ' ') {
        throw new Error(`'${nestingOperator}' is not a supported combinator. ` +
            `Only child combinator (>) and descendant combinator are supported.`);
    }
    let uiAutomatorSelector = 'new UiSelector()';
    if (cssRule.tagName && cssRule.tagName !== '*') {
        let androidClass = [cssRule.tagName];
        if (cssRule.classNames) {
            for (const cssClassNames of cssRule.classNames) {
                androidClass.push(cssClassNames);
            }
            uiAutomatorSelector += `.className("${androidClass.join('.')}")`;
        }
        else {
            uiAutomatorSelector += `.classNameMatches("${cssRule.tagName}")`;
        }
    }
    else if (cssRule.classNames) {
        uiAutomatorSelector += `.classNameMatches("${cssRule.classNames.join('\\.')}")`;
    }
    if (cssRule.id) {
        uiAutomatorSelector += `.resourceId("${formatIdLocator(cssRule.id)}")`;
    }
    if (cssRule.attrs) {
        for (const attr of cssRule.attrs) {
            uiAutomatorSelector += parseAttr(attr);
        }
    }
    if (cssRule.pseudos) {
        for (const pseudo of cssRule.pseudos) {
            uiAutomatorSelector += parsePseudo(pseudo);
        }
    }
    if (cssRule.rule) {
        uiAutomatorSelector += `.childSelector(${parseCssRule(cssRule.rule)})`;
    }
    return uiAutomatorSelector;
}
function parseCssObject(css) {
    switch (css.type) {
        case 'rule':
            return parseCssRule(css);
        case 'ruleSet':
            return parseCssObject(css.rule);
        case 'selectors':
            return css.selectors.map((selector) => parseCssObject(selector)).join('; ');
        default:
            throw new Error(`UiAutomator does not support '${css.type}' css. Only supports 'rule', 'ruleSet', 'selectors' `);
    }
}
function cssToUiAutomatorSelector(cssSelector) {
    let cssObj;
    try {
        cssObj = parser.parse(cssSelector);
    }
    catch (e) {
        throw new Error(`Invalid CSS selector '${cssSelector}'. Reason: '${e}'`);
    }
    try {
        return parseCssObject(cssObj);
    }
    catch (e) {
        throw new Error(`Unsupported CSS selector '${cssSelector}'. Reason: '${e}'`);
    }
}
exports.default = cssToUiAutomatorSelector;
