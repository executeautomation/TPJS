"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const selenium_webdriver_1 = require("selenium-webdriver");
const driverCommandReport_1 = __importDefault(require("../../../rest/messages/driverCommandReport"));
const seleniumHelper_1 = require("./seleniumHelper");
const reportHelper_1 = __importDefault(require("./reportHelper"));
const NON_REPORTED_COMMANDS = ['setImplicitTimeout'];
const WEBDRIVER_TO_SELENIUM_COMMAND = new Map([['takeScreenshot', seleniumHelper_1.SeleniumCommandName.SCREENSHOT]]);
class MobileCommandsReporter {
    constructor(agentClient, reporter) {
        this.agentClient = agentClient;
        this.reporter = reporter;
        this.latestKnownTestName = '';
        this.skipDriverCommandReporting = false;
    }
    setDriverClient(driverClient) {
        this.driverClient = driverClient;
    }
    reportError(commandName, data) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const isError = (_a = data.result.value) === null || _a === void 0 ? void 0 : _a.hasOwnProperty('error');
            if (!isError) {
                return null;
            }
            const driverCommand = seleniumHelper_1.SeleniumHelper.buildSeleniumCommand(commandName);
            driverCommand.setParameters(data.body);
            const errObj = data.result.value;
            let expObj;
            let errMsg;
            switch (errObj.error) {
                case 'no such element':
                    errMsg = `${errObj.message}: ${JSON.stringify(data.body)}`;
                    expObj = new selenium_webdriver_1.error.NoSuchElementError(errMsg);
                    break;
                default:
                    errMsg = errObj.message;
                    expObj = new Error(errMsg);
            }
            this.skipDriverCommandReporting = true;
            try {
                const screenshot = yield ((_b = this.driverClient) === null || _b === void 0 ? void 0 : _b.takeScreenshot());
                const driverCommandReport = new driverCommandReport_1.default(driverCommand, errMsg, false, screenshot);
                this.agentClient.reportDriverCommand(driverCommandReport);
            }
            catch (err) {
            }
            this.skipDriverCommandReporting = false;
            return expObj;
        });
    }
    reportDriverCommand(commandName, data, resolve, reject) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.skipDriverCommandReporting || this.reporter.disableReports || this.reporter.disableCommandReports) {
                resolve(null);
                return;
            }
            if (NON_REPORTED_COMMANDS.indexOf(commandName) > -1) {
                resolve(null);
                return;
            }
            const errObj = yield this.reportError(commandName, data);
            if (errObj) {
                reject(errObj);
                return;
            }
            const commandParams = data.body;
            const commandResult = data.result.value;
            const seleniumCommandName = WEBDRIVER_TO_SELENIUM_COMMAND.get(commandName) || commandName;
            const driverCommand = seleniumHelper_1.SeleniumHelper.buildSeleniumCommand(seleniumCommandName);
            driverCommand.setParameters(commandParams);
            const driverCommandReport = new driverCommandReport_1.default(driverCommand, commandResult, true);
            this.agentClient.reportDriverCommand(driverCommandReport);
            resolve(driverCommandReport);
        });
    }
    reportElementCommand(commandName, data, elementId, resolve, reject) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.reporter.disableReports || this.reporter.disableCommandReports) {
                resolve(null);
                return;
            }
            const errObj = yield this.reportError(commandName, data);
            if (errObj) {
                reject(errObj);
                return;
            }
            const driverCommand = seleniumHelper_1.SeleniumHelper.buildSeleniumCommand(commandName);
            if (commandName === seleniumHelper_1.SeleniumCommandName.SEND_KEYS_TO_ELEMENT) {
                driverCommand.setParameter('value', data.body.text);
            }
            else {
                driverCommand.setParameters(data.body);
            }
            driverCommand.setParameter('id', elementId);
            const driverCommandReport = new driverCommandReport_1.default(driverCommand, data.result.value, true);
            this.agentClient.reportDriverCommand(driverCommandReport);
            resolve(driverCommandReport);
        });
    }
    reportTest(force = false) {
        const currentTestName = reportHelper_1.default.inferTestName();
        if (!this.reporter.disableTestAutoReports &&
            ((this.latestKnownTestName.length > 0 && this.latestKnownTestName !== currentTestName) || force)) {
            this.reporter.test(this.latestKnownTestName, true);
        }
        this.latestKnownTestName = currentTestName;
    }
    reportDriverCommandWrapper(commandName, fn) {
        const mobileCommandsReporter = this;
        if (NON_REPORTED_COMMANDS.indexOf(commandName) > -1) {
            return fn;
        }
        return function wrapCommandFn(...args) {
            return __awaiter(this, void 0, void 0, function* () {
                let commandResult;
                let commandError;
                const resultPromise = new Promise((resolve, reject) => {
                    this.once('result', (data) => __awaiter(this, void 0, void 0, function* () {
                        yield mobileCommandsReporter.reportDriverCommand(commandName, data, resolve, reject);
                    }));
                });
                mobileCommandsReporter.reportTest();
                try {
                    commandResult = yield fn.apply(this, args);
                }
                catch (err) {
                    commandError = err;
                }
                yield resultPromise;
                if (commandError) {
                    throw commandError;
                }
                return commandResult;
            });
        };
    }
    reportElementCommandWrapper(commandName, elementId, fn) {
        return __awaiter(this, void 0, void 0, function* () {
            let commandResult;
            let commandError;
            const resultPromise = new Promise((resolve, reject) => {
                var _a;
                (_a = this.driverClient) === null || _a === void 0 ? void 0 : _a.once('result', (data) => __awaiter(this, void 0, void 0, function* () {
                    yield this.reportElementCommand(commandName, data, elementId, resolve, reject);
                }));
            });
            this.skipDriverCommandReporting = true;
            this.reportTest();
            try {
                commandResult = yield fn();
            }
            catch (err) {
                commandError = err;
            }
            this.skipDriverCommandReporting = false;
            yield resultPromise;
            if (commandError) {
                throw commandError;
            }
            return commandResult;
        });
    }
}
exports.default = MobileCommandsReporter;
