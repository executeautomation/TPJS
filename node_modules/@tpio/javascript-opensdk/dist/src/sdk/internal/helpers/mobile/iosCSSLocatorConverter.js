"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const css_selector_parser_1 = require("css-selector-parser");
const selenium_webdriver_1 = require("selenium-webdriver");
const lodash_1 = __importDefault(require("lodash"));
const parser = new css_selector_parser_1.CssSelectorParser();
parser.registerSelectorPseudos('has');
parser.registerNestingOperators('>', '+', '~');
parser.registerAttrEqualityMods('^', '$', '*', '~');
parser.enableSubstitutes();
const BOOLEAN_ATTRS = ['visible', 'accessible', 'accessibility-container', 'enabled'];
const NUMERIC_ATTRS = ['index'];
const STR_ATTRS = ['label', 'name', 'value', 'type'];
const ALL_ATTRS = [...BOOLEAN_ATTRS, ...NUMERIC_ATTRS, ...STR_ATTRS];
const ATTRIBUTE_ALIASES = [
    ['name', ['id']],
    ['index', ['nth-child']],
];
function toCamelCase(str) {
    if (!str) {
        return '';
    }
    const tokens = str.split('-').map((str) => str.charAt(0).toUpperCase() + str.slice(1).toLowerCase());
    const out = tokens.join('');
    return out.charAt(0).toLowerCase() + out.slice(1);
}
function requireBoolean(css) {
    var _a;
    const val = ((_a = css.value) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || 'true';
    switch (val) {
        case '0':
        case 'false':
            return '0';
        case '1':
        case 'true':
            return '1';
        default:
            throw new TypeError(`'${css.name}' must be true, false or empty. Found '${css.value}'`);
    }
}
function requireAttributeName(css) {
    const attrName = css.name.toLowerCase();
    if (ALL_ATTRS.includes(attrName)) {
        return attrName.toLowerCase();
    }
    for (const [officialAttr, aliasAttrs] of ATTRIBUTE_ALIASES) {
        if (aliasAttrs.includes(attrName)) {
            return officialAttr;
        }
    }
    throw new Error(`'${attrName}' is not a valid attribute. ` + `Supported attributes are '${ALL_ATTRS.join(', ')}'`);
}
function parseAttr(cssAttr) {
    if (cssAttr.valueType && cssAttr.valueType !== 'string') {
        throw new TypeError(`'${cssAttr.name}=${cssAttr.value}' is an invalid attribute. ` +
            `Only 'string' and empty attribute types are supported. Found '${cssAttr.valueType}'`);
    }
    const attrName = toCamelCase(requireAttributeName(cssAttr));
    if (!STR_ATTRS.includes(attrName) && !BOOLEAN_ATTRS.includes(attrName)) {
        throw new Error(`'${attrName}' is not supported. Supported attributes are ` + `'${[...STR_ATTRS, ...BOOLEAN_ATTRS].join(', ')}'`);
    }
    if (attrName === 'index') {
        return { index: cssAttr.value };
    }
    if (BOOLEAN_ATTRS.includes(attrName)) {
        return `${attrName} == ${requireBoolean(cssAttr)}`;
    }
    let value = cssAttr.value || '';
    if (value === '') {
        return `[${attrName} LIKE ${value}]`;
    }
    switch (cssAttr.operator) {
        case '=':
            return `${attrName} == "${value}"`;
        case '*=':
            return `${attrName} MATCHES "${lodash_1.default.escapeRegExp(value)}"`;
        case '^=':
            return `${attrName} BEGINSWITH "${value}"`;
        case '$=':
            return `${attrName} ENDSWITH "${value}"`;
        case '~=':
            return `${attrName} CONTAINS "${value}"`;
        default:
            throw new Error(`Unsupported CSS attribute operator '${cssAttr.operator}'. ` + ` '=', '*=', '^=', '$=' and '~=' are supported.`);
    }
}
function parsePseudo(cssPseudo) {
    if (cssPseudo.valueType && cssPseudo.valueType !== 'string') {
        throw new Error(`'${cssPseudo.name}=${cssPseudo.value}'. ` +
            `Unsupported css pseudo class value type: '${cssPseudo.valueType}'. Only 'string' type or empty is supported.`);
    }
    const pseudoName = requireAttributeName(cssPseudo);
    if (BOOLEAN_ATTRS.includes(pseudoName)) {
        return `${toCamelCase(pseudoName)} == ${requireBoolean(cssPseudo)}`;
    }
    if (pseudoName === 'index') {
        return { index: cssPseudo.value };
    }
}
function parseCssRule(cssRule) {
    const { nestingOperator } = cssRule;
    if (nestingOperator && nestingOperator !== ' ' && nestingOperator !== '>') {
        throw new Error(`'${nestingOperator}' is not a supported combinator. ` +
            `Only child combinator (>) and descendant combinator are supported.`);
    }
    let iosClassChainSelector = '';
    if (cssRule.classNames) {
        throw new selenium_webdriver_1.errors.InvalidSelectorError(`'${[cssRule || '', ...cssRule.classNames].join('.')}'
      is not a valid ios class. Must be a single string (e.g.: XCUIElementTypeWindow) without
      dots separating them`);
    }
    if (cssRule.tagName && cssRule.tagName !== '*' && !cssRule.tagName.toLowerCase().startsWith('xcuielementtype')) {
        const capitalizedTagName = cssRule.tagName.charAt(0).toUpperCase() + cssRule.tagName.slice(1);
        cssRule.tagName = `XCUIElementType${capitalizedTagName}`;
    }
    iosClassChainSelector += cssRule.tagName || '*';
    let attrs = [];
    if (cssRule.id) {
        attrs.push(`name == "${cssRule.id}"`);
    }
    if (cssRule.attrs) {
        for (const attr of cssRule.attrs) {
            attrs.push(parseAttr(attr));
        }
    }
    if (cssRule.pseudos) {
        for (const pseudo of cssRule.pseudos) {
            attrs.push(parsePseudo(pseudo));
        }
    }
    const nonIndexAttrs = attrs.filter((attr) => lodash_1.default.isString(attr));
    if (nonIndexAttrs && nonIndexAttrs.length > 0) {
        iosClassChainSelector += `[\`${nonIndexAttrs.join(' AND ')}\`]`;
    }
    const indexAttr = attrs.find((attr) => lodash_1.default.isObject(attr) && attr.index);
    if (indexAttr) {
        iosClassChainSelector += `[${indexAttr.index}]`;
    }
    if (cssRule.rule) {
        iosClassChainSelector += `/${parseCssRule(cssRule.rule)}`;
    }
    if (cssRule.nestingOperator === '>') {
        return iosClassChainSelector;
    }
    else {
        return `**/` + iosClassChainSelector;
    }
}
function parseCssObject(css) {
    switch (css.type) {
        case 'rule':
            return parseCssRule(css);
        case 'ruleSet':
            return parseCssObject(css.rule);
        case 'selectors':
            return css.selectors.map((selector) => parseCssObject(selector)).join('; ');
        default:
            throw new Error(`iOS Class Chain does not support '${css.type}' css. Only supports 'rule', 'ruleSet', 'selectors'`);
    }
}
function cssToIosClassChainSelector(cssSelector) {
    let cssObj;
    try {
        cssObj = parser.parse(cssSelector);
    }
    catch (e) {
        throw new selenium_webdriver_1.errors.InvalidSelectorError(`Invalid CSS selector '${cssSelector}'. Reason: '${e.message}'`);
    }
    try {
        return parseCssObject(cssObj);
    }
    catch (e) {
        throw new selenium_webdriver_1.errors.InvalidSelectorError(`Unsupported CSS selector '${cssSelector}'. Reason: '${e.message}'`);
    }
}
exports.default = cssToIosClassChainSelector;
